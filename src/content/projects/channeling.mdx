---
id: 1
title: '채널링 SaaS 개발 및 유지보수'
description: '조회수·채널 성장이 고민인 유튜버, 마케터를 위한 서비스로, 채널 데이터와 영상을 분석해 맞춤형 리포트 및 콘텐츠 아이디어를 제공하는 SaaS 입니다. 프론트엔드 파트 리드로 참여했습니다.'
techStack: ['React', 'Vite', 'TypeScript', 'Tailwind CSS', 'Tanstack Query', 'Zustand', 'Chart.js', 'Motion']
team: 'FE 인원 총 4명'
period: '2025.07 ~ 진행 중'
links:
    github:
        name: 'GitHub'
        url: 'https://github.com/channeling-ai/FE'
    demo:
        name: '채널링 사이트'
        url: 'https://chaneling.com'
image:
    url: '/assets/images/channeling/thumbnail.png'
    alt: '채널링 썸네일'
---

### 기여 역할

1. 메인 페이지 및 분석 리포트 로직 UI 구현 및 서버 API 연동
2. Chart.js를 활용한 유튜브 영상 데이터 대시보드 시각화
3. 공통 UI 컴포넌트(Button, Input, Modal 등) 모듈화 및 디자인 시스템 적용
4. 모바일 & 태블릿 & PC 기준 반응형 레이아웃 구현
5. Github Actions, Vercel을 이용한 자동 배포 파이프라인 구축
6. 구글 검색 등록 및 SEO 최적화

### 문제점 & 해결 방법

1. **Canvas 기반 차트와 DOM 툴팁 간의 좌표 동기화 및 렌더링 이슈 해결**
    - **배경**: Chart.js의 기본 툴팁은 스타일 커스텀에 한계가 있어 HTML/CSS를 자유롭게 활용할 수 있는 DOM 기반의 커스텀 툴팁(External Tooltip)을 구현했습니다.
    - **문제**: 초기 렌더링 시에는 툴팁 위치가 정확했으나, 브라우저 스크롤이나 화면 리사이징(Resize) 발생 시 툴팁이 차트를 따라오지 못하고, 허공에 고정되는 현상이 발생했습니다. 절대 좌표(absolute)로 띄운 DOM 요소가 이를 실시간으로 반영하지 못하는 것이 원인이었습니다.
    - **해결**: 차트의 라이프사이클과 브라우저 이벤트를 연동하여 실시간 좌표 동기화 로직을 구축했습니다.
        1. 이벤트 바인딩: `scroll` 및 `resize` 이벤트 리스너를 등록하여 뷰포트 변화를 감지하도록 구현했습니다. 특히 스크롤 이벤트는 캡처링(Capture) 단계에서 감지하여 부모 컨테이너의 스크롤까지 놓치지 않도록 했습니다.
        2. 좌표 재계산 로직: `getBoundingClientRect()`를 활용해 Canvas의 실시간 뷰포트 상대 좌표를 구하고, 이를 기반으로 툴팁의 `top`, `left` 값을 갱신하여 차트와 완벽하게 동기화되도록 만들었습니다.
    - **결과**: 다양한 해상도와 스크롤 환경에서도 툴팁이 차트의 특정 세그먼트에 정확히 고정되어, 사용자에게 이질감 없는 매끄러운 인터랙션 경험을 제공했습니다.
    ![도넛 차트 툴팁 예시](/assets/images/channeling/donut-tooltip.png)

2. **좌표 동기화 로직의 렌더링 성능 최적화 (rAF)**
    - **문제**: 앞서 구현한 실시간 좌표 동기화 로직은 `scroll`과 `resize` 이벤트를 기반으로 동작합니다. 하지만 이들은 짧은 시간에 수백 번 트리거되는 이벤트이기 때문에, 매번 getBoundingClientRect()를 호출하여 리플로우(Reflow)를 유발할 경우 **메인 스레드에 과부하가 걸려 화면이 버벅거리는 현상**이 발생할 위험이 있었습니다.
    - **해결**: 브라우저의 렌더링 주기에 맞춰 실행을 최적화하기 위해 **requestAnimationFrame**을 도입했습니다.
        1. 쓰로틀링(Throttling) 적용: `ticking` 플래그를 사용하여 브라우저가 화면을 그리는 프레임(약 16ms) 동안에는 중복된 연산 요청을 무시하고, 프레임당 단 한 번만 위치 업데이트를 수행하도록 제한했습니다.
    - **결과**: 급격한 스크롤 이동이나 화면 크기 변경 시에도 불필요한 연산을 방지하여 CPU 점유율을 낮췄으며, 60fps의 끊김 없는 부드러운 툴팁 이동을 구현했습니다.

3. **전역 상태 기반의 폴링 아키텍처 도입을 통한 네트워크 비용 절감**
    - **배경**: 사용자는 리포트 생성 요청 후, 생성이 완료될 때까지 Skeleton UI가 적용된 리포트 페이지에서 대기할 수 있습니다. 기존 구조에서는 개요, 분석, 아이디어 3개의 탭이 각각 독립적인 폴링 로직을 수행하고 있었으며, 성공 응답(생성 완료)이 오면 각 탭이 개별적으로 데이터를 조회(Fetch)하여 렌더링하는 방식이었습니다.
    - **문제**: 동일한 리포트 생성 상태를 확인하는 것임에도 불구하고, 탭마다 별도의 폴링이 돌아가고 있어 사용자가 탭을 이동할 때마다 불필요한 중복 API 호출이 발생했습니다. 이는 네트워크 리소스 낭비뿐만 아니라, 다수의 비동기 요청이 겹치며 경쟁 상태(Race Condition)를 유발할 위험이 있었습니다.
    - **해결**: UI와 상태 동기화(폴링)의 관심사를 분리하여 중앙 집중형 전역 폴러(Global Poller) 시스템을 구축했습니다.
    - **아키텍처 변경**: 개별 탭의 폴링 로직을 제거하고, 애플리케이션 최상단(GlobalReportPoller)에서 pendingReportIds 전역 상태를 구독하여 단일 프로세스로 관리하도록 변경했습니다.
    - **결과**: 탭 전환 시 발생하던 중복 요청을 원천 차단하여 API 요청 수를 35% 감소시켰으며, 이에 따라 데이터 전송량을 42% 절감하는 성과를 달성했습니다.

### 배운 점
    
    - 시각화 대시보드 내의 다양한 사용자 인터랙션을 구현하며, 복잡한 데이터 흐름을 제어하고 예측 가능한 UI를 만들기 위한 상태 관리 패턴의 중요성을 깊이 이해했습니다.
    - 프론트엔드 리드로서 명확한 업무 분배와 건강한 코드 리뷰 문화를 주도하는 방법을 배울 수 있었습니다. 팀원들의 적극적인 기술 논의를 이끌어내고, 개인의 성장이 프로젝트의 완성도로 이어지는 '동반 성장'의 가치를 실현했습니다.